sequenceDiagram
    participant FE as Frontend<br/>(React SPA)
    participant API as API Service<br/>(Unified Gateway)
    participant QUERY_DB as Query Database<br/>(PostgreSQL)
    participant CACHE as Redis Cache
    participant KAFKA as Kafka<br/>(Event Bus)
    participant CLUSTER_DB as Battles Database<br/>(PostgreSQL)

    Note over FE,API: User requests battle list

    FE->>API: GET /battles?limit=20
    API->>CACHE: Check cache: battles:list:recent

    alt Cache Hit
        CACHE-->>API: Return cached data
    else Cache Miss
        API->>QUERY_DB: SELECT FROM battle_summaries
        QUERY_DB-->>API: Battle data
        API->>CACHE: SET battles:list:recent (TTL: 60s)
    end

    API-->>FE: JSON response with battles

    Note over FE,API: User clicks battle detail

    FE->>API: GET /battles/{id}
    API->>CACHE: Check cache: battle:{id}

    alt Cache Hit
        CACHE-->>API: Return cached data
    else Cache Miss
        API->>QUERY_DB: SELECT FROM battle_summaries WHERE id=?
        QUERY_DB-->>API: Battle details
        API->>CACHE: SET battle:{id} (TTL: 300s)
    end

    API-->>FE: JSON response with battle details

    Note over KAFKA,CLUSTER_DB: Background: How Query DB stays updated

    CLUSTER_DB->>KAFKA: PUBLISH battle.created event
    KAFKA->>QUERY_DB: CONSUME battle.created
    QUERY_DB->>QUERY_DB: REFRESH MATERIALIZED VIEW battle_summaries

    Note over QUERY_DB: Query DB is eventually consistent<br/>(5min refresh lag)
